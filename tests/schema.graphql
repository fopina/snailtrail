input RaceFilters {
  owner: String
  league: Int
  status: [Int]
  id: [Int]
}

input RaceHistoryFilters {
  token_id: Int!
  category: Int
  league: Int
  distance: Int
  adaptations: [Int]
}

input VisualFilters {
  eyes: Int
  eye_sockets: Int
  mouth: Int
  head: Int
  nostrils: Int
  form: Int
  shell: Int
  bottom: Int
  top: Int
  back: Int
  side: Int
}

input SnailFilters {
  id: [Int]
  family: Int
  klass: Int
  generation: Int
  adaptations: [Int]
  purity: Int
  parent_male: Int
  parent_female: Int
  visuals: VisualFilters
  stats: StatFilters
  stat_season: Int
  owner: String
  gender: Int
  name: String
  status: Int
}

input StatFilters {
  elo: RangeFilter
  level: RangeFilter
  tickets: RangeFilter
  races: RangeFilter
  slime_boost: RangeFilter
  purity: RangeFilter
  generation: RangeFilter
}

input RangeFilter {
  min: Int
  max: Int
}

input IncubateParams {
  owner: String!
  item_id: Int
  market_price_wei: String
  nonce: Int!
  fid: Int!
  mid: Int!
  use_scroll: Boolean
}

input JoinRaceParams {
  token_id: Int!
  race_id: Int!
  address: String!
  signature: String!
}

input BuyItemParams {
  item_id: Int!
  address: String!
  count: Int = 1
  payload: ExtraParams
}

input ExtraParams {
  token_id: Int
  name: String
  use_scroll: Boolean
}

input ProfileParams {
  username: String
  collection_id: Int
  image_id: Int
  twitter: String
  address: String!
}

input MicrowaveParams {
  address: String!
  token_ids: [Int!]!
  signature: String!
  use_scroll: Boolean
}

input PressureParams {
  token_id: Int
  items: [ItemParams!]!
  address: String!
  signature: String!
}

input ChangeAdaptationParams {
  token_id: Int!
  slot: Int!
  address: String!
}

input ItemParams {
  id: Int!
  count: Int!
}

input InventoryFilters {
  item_type: Int
  status: [Int]
  flag: ViewFlag
  family: Int
}

enum ViewFlag {
  ALL
  COOKING
  MIXING
}

type Query {
  snails_promise(
    limit: Int
    offset: Int
    order: Int
    filters: SnailFilters
  ): SnailPromise!
  gene_market_promise(
    limit: Int
    offset: Int
    order: Int
    filters: SnailFilters
  ): SnailPromise!
  marketplace_promise(
    limit: Int
    offset: Int
    order: Int
    filters: SnailFilters
  ): SnailPromise!
  marketplace_stats_promise(market: Int): MarketplaceStatsPromise!
  snail_promise(token_id: Int!): SnailPromise!
  rarity_promise: RarityPromise!
  statics_promise: StaticsPromise!
  races_promise(limit: Int, offset: Int, filters: RaceFilters): RacePromise!
  onboarding_races_promise(
    limit: Int
    offset: Int
    filters: RaceFilters
  ): RacePromise!
  scheduled_races_promise(
    limit: Int
    offset: Int
    filters: RaceFilters
  ): RacePromise!
  finished_races_promise(
    limit: Int
    offset: Int
    filters: RaceFilters
  ): RacePromise!
  mission_races_promise(
    limit: Int
    offset: Int
    filters: RaceFilters
  ): RacePromise!
  mega_races_promise(
    limit: Int
    offset: Int
    filters: RaceFilters
  ): RacePromise!
  race_history_promise(
    limit: Int
    offset: Int
    filters: RaceHistoryFilters
  ): RacePromise!
  simulation_promise(female: Int!, male: Int!): SimulationPromise!
  my_snails_promise(
    owner: String!
    gender: Int
    limit: Int
    offset: Int
    filters: SnailFilters
  ): MySnailsPromise
  my_snails_ranked_promise(
    owner: String!
    league: Int!
    adaptations: [Int]
    limit: Int
    offset: Int
  ): MySnailsPromise
  my_snails_mission_promise(
    owner: String!
    adaptations: [Int]
    limit: Int
    offset: Int
  ): MySnailsPromise
  race_schedule_promise: RaceSchedulePromise
  incubate_promise(params: IncubateParams): IncubatePromise!
  whitelist_promise(address: String!): WhitelistPromise!
  name_status_promise(name: String!): NameStatusPromise!
  race_participants_promise(race_id: Int!): SnailPromise!
  race_dashboard_promise: RaceDashboardPromise!
  shop_items_promise: ShopItemsPromise!
  profile_promise(address: String!): ProfilePromise!
  microwave_promise(params: MicrowaveParams): MicrowavePromise!
  inventory_promise(
    address: String!
    limit: Int
    offset: Int
    filters: InventoryFilters
  ): InventoryPromise!
  pressure_simulation_promise(params: PressureParams): PressurePromise!
}

type Mutation {
  join_mission_promise(params: JoinRaceParams): JoinRacePromise
  join_competitive_promise(params: JoinRaceParams): JoinRacePromise
  join_mega_race_promise(params: JoinRaceParams): JoinRacePromise
  buy_shop_item_promise(params: BuyItemParams): BuyItemPromise
  update_profile_promise(params: ProfileParams): BasicResponse
  apply_pressure_promise(params: PressureParams): PressurePromise
  change_adaptation_promise(params: ChangeAdaptationParams): BasicResponse
}

type Problem {
  problem: [String!]
}

union SnailPromise = Snails | Snail | Problem

union RarityPromise = Rarity | Problem

union StaticsPromise = Statics | Problem

union RacePromise = Race | Races | RaceHistory | Problem

union SimulationPromise = Simulation | Problem

union MySnailsPromise = Snails | Problem

union RaceSchedulePromise = RaceSchedule | Problem

union IncubatePromise = Incubate | Problem

union Stat = MeanStat | CounterStat

union JoinRacePromise = JoinRaceResponse | Problem

union JoinPayload = MissionPayload | CompetitivePayload | MegaRacePayload

union WhitelistPromise = WhitelistStatus | Problem

union NameStatusPromise = NameStatus | Problem

union MarketplaceStatsPromise = MarketplaceStats | Problem

union RaceDashboardPromise = RaceDashboardResponse | Problem

union BuyItemPromise = BuyItemResponse | Problem

union ShopItemsPromise = ShopItemsResponse | Problem

union ProfilePromise = Profile | Problem

union BasicResponse = Response | Problem

union MicrowavePromise = GenericResponse | Problem

union GenericPayload = MicrowavePayload

union InventoryPromise = Inventory | Problem

union PressurePromise = Pressure | Problem

type Pressure {
  snail: Snail
  items: [Int]!
  changes: [Change]!
}

type Change {
  name: String
  description: String
  src: Int
  src_type: Int
  _from: String
  _to: String
}

type GenericResponse {
  status: Int!
  message: String
  payload: GenericPayload
  signature: String
}

type MicrowavePayload {
  owner: String!
  order_id: Int!
  size: Int!
  token_ids: [Int]!
  timeout: Int!
  salt: Int!
  coef: Float!
  fee_wei: String!
  fee_details: [String!]!
}

type Response {
  success: Boolean!
}

type Profile {
  address: String!
  username: String
  image: String
  avatar: Avatar
  avatar_options: [Avatar]
  twitter: String
  favorite_snails: [Int]
  stats: ProfileStats
}

type Avatar {
  name: String
  image_id: Int
  collection_id: Int
  url: String
}

type ProfileStats {
  total_races: Int
  snails: Int
  earned_slime: Float
  earned_avax: Float
  sold: Int
  sold_amount: Float
  bought: Int
  bought_amount: Float
  bred: Int
  burned: Int
  minted: Int
}

type Inventory {
  count: Int
  items: [InventoryItem]
}

type InventoryItem {
  id: Int
  type_id: Int
  name: String
  description: String
  coef: Float
  count: Int
  status: Int
  expires_at: String
}

type ShopItemsResponse {
  items: [ShopItem]
}

type ShopItem {
  id: Int
  name: String
  price: Float
  currency: Int
}

type RaceDashboardResponse {
  dashboard: RaceDashboardStats
}

type RaceDashboardStats {
  mission: RaceStats
  competitive: RaceStats
  mega_race: RaceStats
}

type RaceStats {
  active: Int!
}

type MarketplaceStats {
  volume: Float!
  floors: [MarketStat]
  highs: [MarketStat]
}

type MarketStat {
  id: Int
  name: String
  value: Float
}

type NameStatus {
  status: Boolean!
  message: String
}

type WhitelistStatus {
  whitelist_round: Int!
  anti_bot_round: Int!
  public_round: Int!
  proof: [String]
}

type JoinRaceResponse {
  status: Int!
  message: String
  payload: JoinPayload
  signature: String
}

type MissionPayload {
  race_id: Int!
  token_id: Int!
  address: String!
  athletes: [Int]!
  owners: [String]!
  size: Int!
  completed_races: [CompletedRace]
  timeout: Int!
  salt: Int!
}

type CompetitivePayload {
  race_id: Int!
  token_id: Int!
  address: String!
  entry_fee_wei: String!
  size: Int!
  completed_races: [CompletedRace]
  timeout: Int!
  salt: Int!
}

type MegaRacePayload {
  race_id: Int!
  token_id: Int!
  address: String!
  entry_fee_wei: String!
  size: Int!
  completed_races: [CompletedRace]
  timeout: Int!
  salt: Int!
}

type CompletedRace {
  race_id: Int!
  race_type: Int!
  results: [Int]!
  owners: [String]!
  rewards_wei: [String]
}

type Incubate {
  payload: IncubatorPayload
  signature: String
}

type IncubatorPayload {
  owner: String!
  item_id: Int!
  base_fee_wei: String!
  market_price_wei: String!
  nonce: Int!
  fid: Int!
  mid: Int!
  timeout: Int!
  salt: Int!
}

type Snails {
  snails: [Snail]
  count: Int
}

type Snail {
  id: Int!
  family: String!
  klass: String!
  generation: Int!
  adaptations: [String]!
  purity: Int!
  visuals: [Attribute]
  parent_male: Int!
  parent_female: Int!
  genome_coef: String!
  salt: String!
  name: String
  genome: [String]!
  image: String!
  image_nobg: String!
  image_headshot: String!
  stats: DashboardStats
  more_stats(seasons: [Int]): [SeasonStats]
  colors: Colors
  owner: String
  gender: Gender
  breeding: BreedInfo
  birthday: String
  new_born: Boolean
  queueable_at: String
  market: MarketListing
  holder: String
  gene_market: GeneMarket
  layers: [Layer]
  race_history: [Race]
  burn: BurnInfo
  auras: AuraInfo
  owner_profile: Profile
  slime_boost: Float
  microwave: MicrowaveInfo
}

type MicrowaveInfo {
  slime_boost: String
}

type AuraInfo {
  auras: [Aura]
}

type Aura {
  id: Int
  name: String
  expires_at: String
}

type BurnInfo {
  died_at: String
  cause: String
  cause_id: Int
  burned_by: String
}

type GeneMarket {
  on_sale: Boolean
  price: Float
  price_wei: String
  remainder: Int
  last_sale: Float
  highest_sale: Float
  item_id: Int
  timeout: Int
}

type MarketListing {
  item_id: Int
  price: Float
  on_sale: Boolean
  price_wei: String
  last_sale: Float
  highest_sale: Float
  history: [SoldItem]
}

type SoldItem {
  from: String
  to: String
  price: Float
  at: String
}

type Layer {
  id: Int
  name: String
  image: String
  order: Int
}

type Experience {
  xp: Int!
  level: Int!
  on: Int!
  remaining: Int!
  reward: Int!
}

type BreedInfo {
  breed_status: BreedStatus
  breed_detail: BreedDetail
}

type BreedDetail {
  monthly_breed_limit: Int
  monthly_breed_available: Int
  monthly_breed_used: Int
  children: [Int]
  cycle_start: String
  cycle_end: String
  days_remaining: Float
  breed_count_total: Float
  breed_count_male: Int
  breed_count_female: Int
}

type BreedStatus {
  cycle_start: String
  cycle_end: String
  cycle_gender: Int
  cycle_total: Int
  cycle_remaining: Int
}

type Gender {
  id: Int
  value: String!
  last_change_at: String
  can_change_at: String
}

type Colors {
  body_primary: String
  shell_primary: String
  helm_primary: String
  extension_primary: String
}

type Attribute {
  trait_type: String!
  value: String!
  id: Int!
  count: Int
  percentage: Float
}

type DashboardStats {
  races: Int
  elo: String
  earned_avax: Float
  earned_token: Float
  mission_tickets: Int
  win_ratio: String
  top_three_ratio: String
  experience: Experience
}

type SeasonStats {
  id: Int!
  name: String!
  data: [GameStats]
}

type GameStats {
  id: Int!
  name: String!
  data: [CategoryStats]
}

type CategoryStats {
  id: Int!
  name: String!
  data: [Stat]
}

type CounterStat {
  id: Int!
  name: String!
  count: Int!
}

type MeanStat {
  id: Int!
  name: String!
  count: Int!
  min: Float!
  mean: Float!
  max: Float!
  std: Float!
}

type Rarity {
  rarity: [Attribute]
}

type Statics {
  traits: [TraitType]
}

type TraitType {
  name: String!
  id: Int!
  options: [Attribute]
}

type BuyItemResponse {
  status: Int!
  message: String
  payload: BuyItemPayload
  signature: String
}

type BuyItemPayload {
  item_id: Int!
  order_id: Int!
  currency: Int!
  count: Int!
  price_wei: String!
  address: String!
  timeout: Int!
  salt: Int!
}

type Simulation {
  family: [Probability]
  purity: [Probability]
  klass: [Probability]
  generation: [Probability]
  adaptation: String
}

type Probability {
  name: String
  p: Float
  hint: String
}

type RaceHistory {
  races: [Race]
  count: Int
}

type Races {
  all: [Race]
  own: [Race]
}

type Race {
  id: Int!
  conditions: [String]!
  distance: String!
  league: String!
  status: Int!
  season: String!
  track: String!
  race_type: String!
  prize_pool: String!
  currency: Int!
  starts_at: String
  schedules_at: String
  results: [ResultsTimeData]
  rewards: Rewards
  athletes: [Int]
  participation: Boolean
  race_feed: [RaceFeedResponse]
  reward_status: Int
}

type Rewards {
  total: Float
  base_distribution: [Float]
  final_distribution: [Float]
  multipliers: [Float]
}

type RaceSchedule {
  current: Race
  next: Race
}

union RaceFeedResponse = SectorDataResponse | TimeDataResponse | Problem

type AthleteData {
  id: Int!
  distance: Float
}

type AthleteTimeData {
  id: Int
  time: Float
}

type ResultsTimeData {
  token_id: Int
  time: Float
}

type SectorDataResponse {
  sector_data: [AthleteData]
  sector: Int!
}

type TimeDataResponse {
  time_data: [AthleteTimeData]
  next_race: Int
}
